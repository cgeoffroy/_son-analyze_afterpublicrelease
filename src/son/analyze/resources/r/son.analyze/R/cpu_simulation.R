#' A cpu simulation package
#' @name cpu_simulation
#' @import markovchain ggplot2
NULL


stateNames <- c("L","M","H")


regMC <- {
  probs <- matrix(c(.75, .15, .10, .4, .6,0, .3, .3, .4),
                  nrow = 3, byrow = TRUE,
                  dimnames = list(stateNames, stateNames))
  new("markovchain", stateNames, byrow = TRUE, transitionMatrix = probs,
      name = "cpuSimChain")
}
# plot(regMC)
# stop("debug graph") 


#' Simulate some cpu load using a Markov chain
#'
#' The simulation generates \code{cyclePerDay} events for \code{nbOfDays} using
#' the same pattern for each day. The simulation also compute an Arima forecast of
#' length \code{predWindow}.
#'
#' @param nbOfDays A positive integer
#' @param cyclePerDay A positive integer
#' @param predWindow A positive integer
#' @return A list l resulting from the simulation.
#'   \code{l$df} is a data frame of length \code{nbOfDays * cyclePerDay} containing the raw metrics, an index, a \code{lm} prediction and the fitted values.
#'   \code{l$forecastDf} is a data frame of length \code{predWindow} containing an Arima forecast.
#'   \code{l$maxX} is an integer giving the maximum abscissa obtained when combining the two data frame.
#' @export
simulate <- function(nbOfDays = 3, cyclePerDay = 300, predWindow = 80) {
  generateCycle <- function(dayTrend) {
    stateToCpuValue <- function(cpuState, localTrend) {
      # convert a state to a random cpu metric
      randCpuMetric <- switch(cpuState,
                              "L" = rnorm(1, mean = 0.01, sd = 0.05),
                              "M" = rnorm(1, mean = 0.5, sd = 0.05),
                              "H" = rnorm(1, mean = 0.8, sd = 0.05))
      sanitize <- function(cpuMetric) {
        # force cpu value in the range [0, 1]
        return(max(.Machine$double.eps, min(1, cpuMetric)))
      }
      return(sanitize(randCpuMetric * localTrend))
    }
    # draw `n` sample states from the markov chain and get a time serie
    cpuMCts <- rmarkovchain(n = cyclePerDay, object = regMC, t0 = stateNames[1])
    # convert states to metrics
    metrics <- unlist(purrr::map2(cpuMCts, dayTrend, stateToCpuValue))
    return(data.frame(States = cpuMCts, CPULoadRaw = metrics))
  }
  
  df <- data.frame(States = list(), CPULoadRaw = list())
  baseCycleTrend <- 1.5  # during a cycle, boost the value by 1.5
  for (i in 1:nbOfDays) {
    currentCycle <- generateCycle(seq(1, baseCycleTrend,
                                      length.out = cyclePerDay))
    df <- rbind(df, currentCycle)  # concat the generated cycle to the accumulator
    baseCycleTrend <- baseCycleTrend * 1.021  # grow the trend between cycles
  }

  # the CPULoadRaw must be convert to a timeserie with adequate frequencie to
  # help pattern detection
  df$CPULoadRaw <- ts(df$CPULoadRaw, frequency = cyclePerDay)

  ## df$CPULoad <- smooth(df$CPULoadRaw)
  ## df$CPULoad <- fitted(loess(y ~ x, span=0.02,
  ##                            data.frame(x=1:length(df$CPULoadRaw),
  ##                                       y=df$CPULoadRaw)))

  df$index <- seq(1:length(df$CPULoadRaw))
  df$lmModelPrediction <- predict(lm(CPULoadRaw ~ index, data = df))  # compute a basic mean
  
  ## lambda <- forecast::BoxCox.lambda(df$CPULoadRaw)
  ## trans.vector = forecast::BoxCox( df$CPULoad, lambda)
  
  predictionModel <- forecast::Arima(df$CPULoadRaw, order = c(1, 2, 3))
  #predictionModel <- forecast::auto.arima(df$CPULoadRaw, trace = TRUE, parallel = TRUE)
  df$fitted <- fitted(predictionModel)
  
  someForecast <- forecast::forecast(df$fitted, h = predWindow)
  forecastDf <- data.frame(
    x = seq(length(someForecast$x) + 1, length(someForecast$x) + length(someForecast$mean)),
    forecast = as.numeric(someForecast$mean))
  return(list(df = df, forecastDf = forecastDf, maxX = length(df$index) + predWindow))
}


reverseSqrtScale <- function(maxX) {
  someTransform <- function(x) {
    return(sqrt(maxX - 1) - sqrt(maxX - pmin(maxX, x)))
  }

  someInverse <- function(x) {
    sapply(x, function(e) {
      if (is.nan(e)) {
        return(maxX)
      } else {
        return(trunc(-e^2 + 2 * e * sqrt(maxX - 1) + 1))
      }
    })
  }

  return (scales::trans_new("reverseSqrtScale", someTransform, someInverse))
}


createBasePlot <- function (simulation) {
  return (ggplot(simulation$df, aes_string('index', 'CPULoadRaw')) +
          geom_line(aes_string(y = 'fitted'), color = "orange4", size = 0.1) +
          geom_point(aes_string(color = 'States'), size = 0.5) +
          geom_line(aes_string(y = 'lmModelPrediction'), color = "yellow") +
          geom_line(aes_string(x = 'x', y = 'forecast'), data = simulation$forecastDf, color = "magenta", size = 0.2) +
          xlab("time") +
          ylab("cpu"))
}


#' Display a simulation and its forecast in two ggplot2 plots.
#'
#' @param simulation A simulation generated by \code{simulate}.
#'
#' @export
displaySimulation <- function(simulation) {
  p0 <- createBasePlot(simulation) +
    scale_x_continuous("time (linear scale)", expand = c(0, 0), limits=c(0, simulation$maxX)) +
    scale_y_continuous("cpu load", expand = c(0, 0)) +
    ggtitle("cpu simulation")


  p1 <- createBasePlot(simulation) +
    scale_x_continuous("time (log scale)",
                       trans = reverseSqrtScale(simulation$maxX), expand = c(0, 0), limits=c(0, simulation$maxX)) +
    scale_y_continuous("cpu load", expand = c(0, 0)) # +
#    ggtitle("cpu simulation")                     


  gridExtra::grid.arrange( p0, p1, ncol = 1)
}


## N <- 300
## pred_windows <- 80
## nbCycles <- 3
## aSimulation <- simulate(nbCycles, N, pred_windows)  # simulate `nbCycles` cycles

## displaySimulation(aSimulation)
